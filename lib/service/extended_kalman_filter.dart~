// service/extended_kalman_filter.dart

import 'package:flutter_background_geolocation/flutter_background_geolocation.dart' as bg;
import 'package:latlong2/latlong.dart' as ll;
import 'dart:math' as math;

/// 간단 예시: 2D EKF (x, y, vx, vy)
class ExtendedKalmanFilter {
  // 상태 벡터: [ x, y, vx, vy ]
  List<double> X = [0, 0, 0, 0];

  // 공분산 행렬 P (4x4)
  // 초기 오차 큰 값으로
  List<double> P = [
    1000, 0,    0,    0,
    0,    1000, 0,    0,
    0,    0,    1000, 0,
    0,    0,    0,    1000,
  ];

  // 프로세스 잡음 공분산 (Q)
  // (실제로는 상황에 맞춰 튜닝)
  List<double> Q = [
    0.1, 0,   0,   0,
    0,   0.1, 0,   0,
    0,   0,   0.1, 0,
    0,   0,   0,   0.1,
  ];

  // GPS 관측 잡음 공분산 (R) 2x2
  // (실제로는 accuracy나 환경에 따라 조정)
  List<double> Rgps = [
    5.0, 0.0,
    0.0, 5.0,
  ];

  // -----------------------------------------------------------------------
  // (1) 예측단계: 일정 dt 후 상태 & 공분산 예측
  //     (x, y, vx, vy) -> F * X
  // -----------------------------------------------------------------------
  void predict(double dt) {
    // 상태 예측 (선형 가정)
    // x_k = x_{k-1} + vx*dt
    // y_k = y_{k-1} + vy*dt
    double x = X[0];
    double y = X[1];
    double vx = X[2];
    double vy = X[3];

    double x_new = x + vx*dt;
    double y_new = y + vy*dt;
    double vx_new = vx;
    double vy_new = vy;

    X[0] = x_new;
    X[1] = y_new;
    X[2] = vx_new;
    X[3] = vy_new;

    // 공분산 P 예측
    // P^- = F P F^T + Q
    // 여기서 F = [[1,0,dt,0],
    //              [0,1,0,dt],
    //              [0,0,1,0],
    //              [0,0,0,1]]
    // 단순 행렬 연산 예시 -> 실제론 더 깔끔히 작성 가능
    List<double> F = [
      1,0,dt,0,
      0,1,0,dt,
      0,0,1,0,
      0,0,0,1
    ];
    // 계산 함수 만들어서 사용 or 간단히 직접 곱하기
    final P_old = matrixCopy(P);
    final Ftrans = matrixTranspose(F, 4,4);
    var FP = matrixMultiply(F, P_old, 4,4,4);
    var FPFt = matrixMultiply(FP, Ftrans, 4,4,4);
    var P_pred = matrixAdd(FPFt, Q, 16);

    P = P_pred;
  }

  // -----------------------------------------------------------------------
  // (2) GPS 관측 업데이트
  // -----------------------------------------------------------------------
  void updateGPS(double gpsX, double gpsY) {
    // 관측 z = [gpsX, gpsY]
    // h(X) = [x, y]
    double hx = X[0];
    double hy = X[1];

    double y1 = gpsX - hx;
    double y2 = gpsY - hy;

    // H = [[1,0,0,0],
    //       [0,1,0,0]]
    // S = H P^- H^T + R
    // K = P^- H^T S^-1
    List<double> H = [
      1,0,0,0,
      0,1,0,0,
    ];
    var Ht = matrixTranspose(H,2,4);

    var PHt = matrixMultiply(P, Ht, 4,4,2);  // 4x2
    var HP = matrixMultiply(H, P, 2,4,4);    // 2x4
    var HPHt = matrixMultiply(HP, Ht, 2,4,2); // 2x2
    var S = matrixAdd(HPHt, Rgps, 4); // 2x2

    // S^-1
    var S_inv = invert2x2(S);

    // K = P^- H^T S^-1 (4x2)
    var K = matrixMultiply(PHt, S_inv, 4,2,2);

    // 잔차 y_k
    // y = [y1, y2]
    // x^+ = x^- + K*y
    X[0] = X[0] + (K[0]*y1 + K[1]*y2);
    X[1] = X[1] + (K[2]*y1 + K[3]*y2);
    X[2] = X[2] + (K[4]*y1 + K[5]*y2);
    X[3] = X[3] + (K[6]*y1 + K[7]*y2);

    // P^+ = (I-KH)P^-
    // KH =  (4x2)(2x4)=4x4
    var KH = matrixMultiply(K, H, 4,2,4);
    var I4 = [1,0,0,0,
      0,1,0,0,
      0,0,1,0,
      0,0,0,1];
    var ImKH = matrixSubtract(I4, KH, 16);
    var newP = matrixMultiply(ImKH, P, 4,4,4);

    P = newP;
  }

  // 아래 간단한 행렬 유틸들 (실전에서는 더 효율적 코드나 라이브러리 사용)
  List<double> matrixCopy(List<double> src) => List.from(src);

  List<double> matrixTranspose(List<double> M,int rows,int cols){
    // M is rows x cols
    // transpose => cols x rows
    List<double> T = List.filled(rows*cols,0);
    for(int r=0; r<rows; r++){
      for(int c=0; c<cols; c++){
        T[c*rows+r] = M[r*cols+c];
      }
    }
    return T;
  }

  List<double> matrixMultiply(List<double> A, List<double> B, int rA,int cA,int cB){
    // A: rA x cA
    // B: cA x cB
    // result: rA x cB
    List<double> R = List.filled(rA*cB,0);
    for(int i=0; i<rA; i++){
      for(int j=0; j<cB; j++){
        double sum=0;
        for(int k=0; k<cA; k++){
          sum += A[i*cA+k]*B[k*cB+j];
        }
        R[i*cB+j] = sum;
      }
    }
    return R;
  }

  // 행렬 더하기 (동일 차원)
  List<double> matrixAdd(List<double> A,List<double> B,int len){
    // len=4 for 2x2, len=16 for 4x4
    var R=List.filled(len,0.0);
    for(int i=0;i<len;i++){
      R[i]=A[i]+B[i];
    }
    return R;
  }

  // 행렬 빼기
  List<double> matrixSubtract(List<double> A,List<double> B,int len){
    var R=List.filled(len,0.0);
    for(int i=0;i<len;i++){
      R[i]=A[i]-B[i];
    }
    return R;
  }

  // 간단히 2x2 역행렬
  // S= [a,b; c,d]
  // S^-1=1/det * [ d,-b; -c,a]
  List<double> invert2x2(List<double> M) {
    double a=M[0], b=M[1], c=M[2], d=M[3];
    double det= a*d - b*c;
    if(math.pow(det,2)<1e-10){
      // 역행렬 불가 -> 그냥 그대로 리턴 or 에러
      return [1,0,0,1];
    }
    double invdet=1.0/det;
    return [ d*invdet, -b*invdet,
      -c*invdet, a*invdet ];
  }

  // -------------------------------------------------------
  // 편의 Getter: 예) x, y
  // -------------------------------------------------------
  double get x => X[0];
  double get y => X[1];
  double get vx => X[2];
  double get vy => X[3];
}
